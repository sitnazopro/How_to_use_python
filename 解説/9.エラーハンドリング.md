# Pythonの応用：エラーハンドリング (try...except)

プログラムを実行していると、予期せぬエラーが発生することがあります。例えば、ユーザーが数値を入力すべきところに文字列を入力したり、存在しないファイルを開こうとしたり。このようなエラーが発生すると、プログラムはクラッシュ（強制終了）してしまいます。

**エラーハンドリング**とは、そうしたエラー（Pythonでは**例外 (Exception)** と呼びます）を事前に予測し、プログラムがクラッシュしないように適切に対処するための仕組みです。

---

## 1. `try` と `except`

最も基本的なエラーハンドリングの構文が `try...except` ブロックです。

-   `try` ブロック: エラーが発生する可能性のあるコードをこの中に入れます。
-   `except` ブロック: `try` ブロック内でエラーが発生した場合に、実行される処理をこの中に入れます。

**構文:**
```python
try:
    # エラーが発生するかもしれない処理
except:
    # エラーが発生したときの処理
```

**例: ユーザー入力の処理**
```python
try:
    age_str = input("あなたの年齢を入力してください: ")
    age = int(age_str)  # 文字列を整数に変換しようとするとエラーの可能性
    print(f"来年、あなたは {age + 1} 歳になります。")
except:
    print("エラー: 数値を入力してください。")

print("プログラムを終了します。")
```
このコードでは、もしユーザーが "abc" のような数でない文字列を入力すると `int()` が `ValueError` という例外を発生させます。`except` ブロックがそのエラーを捕捉（キャッチ）し、「数値を入力してください。」と表示して、プログラムはクラッシュせずに続行します。

---

## 2. 特定の例外を捕捉する

上記の例の `except:` は、すべての種類のエラーを捕捉してしまいます。しかし、実際には**どのようなエラーを想定しているのかを明示する**のが良いプログラミング作法です。

**例: `ValueError` だけを捕捉する**
```python
try:
    age_str = input("あなたの年齢を入力してください: ")
    age = int(age_str)
    print(f"10をあなたの年齢で割ると: {10 / age}") # ZeroDivisionErrorの可能性
except ValueError:
    print("エラー: 年齢は数値で入力してください。")
```
この場合、もしユーザーが `0` を入力すると `ZeroDivisionError` が発生しますが、この `except` ブロックは `ValueError` しか捕捉しないため、プログラムはクラッシュします。

複数の `except` ブロックを書くことで、エラーの種類に応じた処理ができます。

```python
try:
    age_str = input("あなたの年齢を入力してください: ")
    age = int(age_str)
    print(f"10をあなたの年齢で割ると: {10 / age}")
except ValueError:
    print("エラー: 年齢は数値で入力してください。")
except ZeroDivisionError:
    print("エラー: 0歳では計算できません。")
```

---

## 3. `else` ブロック

`else` ブロックは、`try` ブロックで**例外が発生しなかった場合**にのみ実行されます。

**構文:**
```python
try:
    # 処理
except:
    # エラー時の処理
else:
    # エラーがなかった場合にのみ実行したい処理
```

**例:**
```python
try:
    num_str = input("数値を入力してください: ")
    num = int(num_str)
except ValueError:
    print("入力が正しくありません。")
else:
    # tryブロックが成功した場合のみ実行される
    print(f"入力された数値の2倍は {num * 2} です。")
```

---

## 4. `finally` ブロック

`finally` ブロックは、**例外が発生したかどうかに関わらず、必ず最後に実行される**処理を書く場所です。

これは、ファイルを開いた後に必ず閉じる、ネットワーク接続を必ず切断するなど、「後片付け」処理に非常によく使われます。

**構文:**
```python
try:
    # 処理
except:
    # エラー時の処理
finally:
    # 成功してもエラーになっても、必ず実行される処理
```

**例:**
```python
f = None # ファイル変数をtryの外で定義
try:
    f = open("some_file.txt", "r")
    content = f.read()
    print(content)
except FileNotFoundError:
    print("ファイルが見つかりません。")
finally:
    # ファイルが開かれていれば、必ず閉じる
    if f:
        f.close()
        print("ファイルをクローズしました。")
```

エラーハンドリングを適切に行うことで、予期せぬ事態にも対応できる、ユーザーにとって親切で安定したプログラムを作成することができます。
